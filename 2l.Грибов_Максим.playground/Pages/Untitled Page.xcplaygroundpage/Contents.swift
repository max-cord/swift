import Foundation
// Написать функцию, которая определяет, четное число или нет.

func delsecond(_ a1 : Int) {
    if a1 % 2 == 0 {
        print("Число \(a1), четное")
    } else {
        print("Число \(a1), нечетное")
    }
}
delsecond(9)

//Написать функцию, которая определяет, делится ли число без остатка на 3.
 func delthird(_ a2 : Int) {
    if a2 % 3 == 0 {
        print("Число \(a2), делится на 3 без остатка")
    } else {
        print("Число \(a2), не делится на 3 без остатка")
    }
 }
delthird(9)

//Создать возрастающий массив из 100 чисел.

var arr = (1...99).map( {_ in Int.random(in: 1...500)} )
arr.sort()

//ниже код для получения массива от 0 до 99 - мне показался неинтересным. Но в работающем коде не нашел решения, как сделать, чтобы числа в массиве были уникальными.
/*var arr: [Int] = []
for i in 0...99 {
   arr.append(i)
}*/
//Удалить из этого массива все четные числа и все числа, которые не делятся на 3.
for value in arr {
    if (value % 2) == 0 {
        arr.remove(at: arr.firstIndex(of: value)!)
    }
}

for value in arr {
    if (value % 3) == 0 {
        arr.remove(at: arr.firstIndex(of: value)!)
    }
}
print(arr)

    //5. * Написать функцию, которая добавляет в массив новое число Фибоначчи, и добавить при помощи нее 50 элементов.
    //Числа Фибоначчи определяются соотношениями Fn=Fn-1 + Fn-2.
func fib(_ n: Int) -> Int{
    if n == 0{
        return 0
    }
    else if n == 1{
        return 1
    }
    return fib(n-1) + fib(n-2)
}
var fibArray = [Int]()
for n in 0 ..< 10 {
    fibArray.insert(fib(n), at: (n))
}
print(fibArray)

// * Заполнить массив из 100 элементов различными простыми числами. Натуральное число, большее единицы, называется простым, если оно делится только на себя и на единицу. Для нахождения всех простых чисел не больше заданного числа n, следуя методу Эратосфена, нужно выполнить следующие шаги:
//a. Выписать подряд все целые числа от двух до n (2, 3, 4, ..., n).
//b. Пусть переменная p изначально равна двум — первому простому числу.
//c. Зачеркнуть в списке числа от 2 + p до n, считая шагом p..
//d. Найти первое не зачёркнутое число в списке, большее, чем p, и присвоить значению переменной p это число.
//e. Повторять шаги c и d, пока возможно.

